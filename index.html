
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Photo Fill World Map</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 20px; }
    #root { width: 100%; }
    button { cursor: pointer; }
  </style>
  <!-- React + ReactDOM via CDN -->
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Babel for JSX -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- d3 + topojson -->
  <script src="https://unpkg.com/d3@7"></script>
  <script src="https://unpkg.com/topojson-client@3"></script>
</head>
<body>
  <h1>Interactive Photo-Fill World Map</h1>
  <p>Click any country or US state to upload a picture.</p>

  <div id="root"></div>

  <script type="text/babel">

const { useEffect, useRef, useState } = React;

function PhotoFillWorldMap({ width = 1200, height = 700 }) {
  const svgRef = useRef(null);
  const [features, setFeatures] = useState([]);
  const [images, setImages] = useState({});
  const projectionRef = useRef(
    d3.geoEquirectangular().scale(width/6.5).translate([width/2, height/2])
  );

  useEffect(() => {
    async function load() {
      const worldResp = await fetch("https://unpkg.com/world-atlas@2.0.2/world/110m.json");
      const worldTopo = await worldResp.json();
      const worldCountries = topojson.feature(worldTopo, worldTopo.objects.countries).features;

      const usResp = await fetch("https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json");
      const usTopo = await usResp.json();
      const usStates = topojson.feature(usTopo, usTopo.objects.states).features;

      const filteredWorld = worldCountries.filter(f => f.id !== 840 && f.id !== "840");

      const usFeatures = usStates.map(s => ({
        ...s,
        id: "US-" + s.id,
        properties: {
          ...s.properties,
          name: s.properties.name || s.properties.NAME || ("US-" + s.id)
        }
      }));

      setFeatures([...filteredWorld, ...usFeatures]);
    }
    load();
  }, []);

  useEffect(() => {
    if (!features.length) return;
    const svg = d3.select(svgRef.current);
    svg.selectAll("*").remove();
    const defs = svg.append("defs");
    const g = svg.append("g");

    const projection = projectionRef.current;
    const path = d3.geoPath().projection(projection);

    g.selectAll("path").data(features)
      .join("path")
      .attr("d", path)
      .attr("stroke", "black")
      .attr("fill", d => images[d.id] ? `url(#img-${d.id})` : "white")
      .on("click", (event, d) => {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = "image/*";
        input.onchange = e => {
          const file = e.target.files[0];
          const reader = new FileReader();
          reader.onload = () => setImages(prev => ({...prev, [d.id]: reader.result}));
          reader.readAsDataURL(file);
        };
        input.click();
      });

    Object.keys(images).forEach(id => {
      defs.append("pattern")
        .attr("id", `img-${id}`)
        .attr("patternUnits", "objectBoundingBox")
        .attr("width", 1)
        .attr("height", 1)
        .append("image")
        .attr("href", images[id])
        .attr("preserveAspectRatio", "xMidYMid slice")
        .attr("width", 1)
        .attr("height", 1);
    });

    const zoom = d3.zoom().scaleExtent([1, 50]).on("zoom", e => g.attr("transform", e.transform));
    svg.call(zoom);
  }, [features, images]);

  return (
    <svg ref={svgRef} width={width} height={height} style={{background:"#f8f8f8"}}></svg>
  );
}

ReactDOM.createRoot(document.getElementById("root")).render(<PhotoFillWorldMap />);
  </script>
</body>
</html>
